
## 1. 项目概览

**【开场白】**
大家好，今天我要分享的是 **ElectTool**。一个基于 Electron + Vue 3 + Node.js 的全栈开发案例。

### 1.3 ** Electron 应用全栈架构交互流程图 **

我们可以把这张图拆解为三个核心部分来详细讲解：客户端（Electron 内部）、通信桥梁（IPC 与 网络）、以及服务端（Node.js 后端）
#### 第一部分：客户端（Electron 内部交互）

这部分主要展示了 Electron 如何安全地将网页请求转化为系统操作。
1. 用户与渲染进程
用户操作：在界面上点击按钮（例如“读取文件”或“开始游戏”）。
Vue 渲染进程页：这是用户看到的界面。它本质上运行在 Chrome 的渲染进程中，就像一个普通的网页。它不能直接访问电脑的文件系统或数据库，否则会有极大的安全风险（比如网页里的恶意代码偷走你的文件）。
2. 安全通信桥梁
Preload Script (预加载脚本)：这是 Electron 安全模型的核心。
流程：Vue 组件调用 window.electronAPI.xxx()。这并不是直接调用主进程，而是调用了预加载脚本暴露出来的接口。
作用：它就像一个“安检门”。预加载脚本拥有 Node.js 权限，但它只暴露出有限的、安全的函数给前端。前端不知道具体的实现细节，只知道“调这个函数能获取数据”。
3. 主进程
IPC (Inter-Process Communication)：当预加载脚本发起调用后，通过 IPC 通道将消息发送给主进程。
Native Ops (原生操作)：主进程接收到消息后，执行真正的 Node.js 代码，比如用 fs 模块读写文件、用 os 模块获取系统信息，或者控制窗口的最小化/最大化。
总结： 客户端部分的流程是 UI -> 安全接口 -> IPC -> 系统底层。

#### 1.3.2 第二部分：服务端（Node.js 后端处理）
当 Electron 需要获取复杂的数据（比如 AI 对话历史、用户列表）或进行实时通信（下五子棋）时，它会连接到独立运行的后端服务。这部分展示了经典的 MVC 架构 是如何处理请求的：

入口与路由
后端服务启动后，监听特定端口。
Router：就像前台接待员。当请求进来时（比如 GET /api/ai），路由器判断：“这个请求是关于 AI 的，把它转给 AI 部门处理”。
控制器
Controller：就像部门经理。它不干具体的脏活累活，只负责“指挥”。
流程：它检查前端传来的参数对不对（校验），然后命令 Service 层去干活。拿到结果后，它负责把结果包装成统一的 JSON 格式返回给前端。
服务层
Service：这就是真正的“业务逻辑”中心。
流程：比如计算 AI 的回复逻辑、判断五子棋胜负的算法、数据清洗等。如果需要数据，它会调用 Repository 层。
仓储与数据库
Repository：它只懂 SQL，负责和数据库直接对话。
SQLite：项目使用轻量级数据库存储数据。Repo 执行 SQL 语句，把数据取出来传给 Service。
总结： 服务端部分的流程是 路由分发 -> 经理指挥 -> 专家处理 -> 搬运工存取数据。

#### 1.3.3 第三部分：闭环（数据回到界面）
图中的箭头最后形成了一个回路，这是数据流向的关键：

向上返回：
SQLite 查出数据 -> Repo -> Service -> Controller。
Controller 将数据变成 JSON 字符串，通过网络发送回 Electron 主进程。
IPC 回调：
Electron 主进程拿到数据后，通过 IPC 机制，将结果 Promise resolve（解决）给预加载脚本。
UI 渲染：
预加载脚本把结果传回给 Vue 组件。
Vue 组件接收到数据，更新页面的状态，用户就在屏幕上看到了最新的内容。

**【功能演示】**
现在我启动应用带大家看一看：

1.  **工具箱**：用“图片格式转换”组件来演示 Electron 如何操作本地文件系统。
2.  **GIS 可视化**：利用 WebGL 展示地球飞线效果。
3.  **实时服务**：用一个双人对战五子棋的小游戏来实现简单的socket通信。

---

## 2. Electron 进程架构

#### 2.1.1 窗口创建与安全配置
注意这段配置。首先我把沙箱关了，是为了兼容原生模块；但为了安全，我强制开启了上下文隔离。这就像把网页关在笼子里，只给它留一根专门喂食的管子，这样即使网页里有恶意代码，也偷不到电脑里的文件。
**【配置详解】**

1.  **`sandbox: false` (禁用沙箱)**
    *   **作用**：Chromium 的沙箱机制可以将渲染进程限制在一个受限环境中，无法访问文件系统或操作系统资源。
    *   **为什么禁用**：虽然开启沙箱更安全，但在某些需要使用大量 Node.js 原生模块（如 C++ 扩展）或某些特定的 Electron API 时，开启沙箱可能会导致兼容性问题。本项目为了开发便利和确保 native 模块（如 `better-sqlite3`）的稳定性选择了禁用，但在生产级高安全应用中建议尽可能开启。

2.  **`contextIsolation: true` (开启上下文隔离)**
    *   **作用**：这是 **最重要的安全设置**。它确保预加载脚本（Preload Script）和渲染进程的网页代码运行在两个独立的 JavaScript 上下文中。
    *   **为什么开启**：如果关闭，网页代码可以修改 JS 原型链（Prototype Pollution），进而影响预加载脚本的执行逻辑，甚至窃取特权接口。开启后，两者通过 `contextBridge` 进行有限的数据交换，彻底切断了恶意代码的攻击路径。

3.  **`nodeIntegration: false` (禁用 Node.js 集成)**
    *   **作用**：决定渲染进程是否拥有完整的 Node.js 环境（即是否能使用 `require()`, `process`, `fs` 等）。
    *   **为什么禁用**：如果开启，网页中的任何脚本（包括第三方广告或被注入的 XSS 脚本）都能直接操作用户的文件系统、运行 Shell 命令，后果不堪设想。禁用它是防止 RCE（远程代码执行）攻击的第一道防线。

4.  **`enableRemoteModule: false` (禁用 Remote 模块)**
    *   **作用**：Remote 模块允许渲染进程直接调用主进程对象（如 `remote.app`, `remote.BrowserWindow`）。
    *   **为什么禁用**：这是一个已被官方废弃且极不安全的模块。它不仅性能低下（跨进程同步调用），而且会绕过上下文隔离和沙箱机制，让渲染进程拥有过大的权限。现在推荐完全使用 IPC 通信替代。

#### 2.1.3 IPC 消息处理器
注册监听，处理渲染进程发送的消息，例如窗口关闭，最小化，访问文件等操作

### 2.2 预加载脚本 (Preload Script)
主要是提供一些安全的api给全局 window 对象，前端代码只能调用暴露出来的一些api，大大提升了安全性

### 2.3 渲染进程 (Renderer Process)
渲染进程其实就是前端最熟悉的平时开发的单页面